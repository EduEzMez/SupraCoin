<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Supra</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.0.1"></script>
    <style>
        body {
            background-color: #000000; /* Fondo oscuro inspirado en Supra */
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            text-align: center;
        }
        h1 {
            color: #ffffff;
            font-size: 2.5em;
        }
        #signal {
            font-size: 2em;
            font-weight: bold;
            margin: 20px 0;
        }
        .buy {
            color: #00ff00; /* Verde para comprar */
        }
        .sell {
            color: #ff0000; /* Rojo para vender */
        }
        #price {
            font-size: 1.5em;
            margin: 10px 0;
        }
        #advice {
            font-size: 1.2em;
            margin: 20px 0;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        #rsi, #atr, #volume-trend {
            font-size: 1.1em;
            margin: 10px 0;
        }
        #chart-container {
            max-width: 800px;
            margin: 20px auto;
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
        }
        button {
            background-color: #6a00ff; /* Morado de Supra */
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #8b3aff;
        }
        #error {
            color: #ff4444;
            font-size: 1.2em;
            margin: 10px 0;
        }
        #version {
            font-size: 0.8em;
            color: #cccccc;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Análisis de Supra</h1>
    <div id="signal">Cargando datos...</div>
    <div id="price"></div>
    <div id="error"></div>
    <div id="advice"></div>
    <div id="rsi"></div>
    <div id="atr"></div>
    <div id="volume-trend"></div>
    <div id="chart-container">
        <canvas id="priceChart"></canvas>
    </div>
    <button id="refresh">Actualizar Ahora</button>
    <p id="version">v0.2</p>

    <script>
        let chart;
        let historicalData = [];
        let currentSignal = '';
        const atrPeriod = 14;
        const rsiPeriod = 14;
        const fibLevels = [0, 0.236, 0.382, 0.5, 0.618, 1];

        async function fetchData() {
            try {
                // Obtener precio actual de Supra usando CoinGecko con ID correcto 'supra'
                const currentResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=supra&vs_currencies=usd');
                const currentData = await currentResponse.json();
                if (!currentData.supra || !currentData.supra.usd) {
                    throw new Error('No se encontró el precio actual para Supra en CoinGecko');
                }
                const currentPrice = currentData.supra.usd;

                // Obtener datos históricos de los últimos 7 días (horarios)
                const historicalResponse = await fetch('https://api.coingecko.com/api/v3/coins/supra/market_chart?vs_currency=usd&days=7&interval=hourly');
                const historicalJson = await historicalResponse.json();
                if (!historicalJson.prices || historicalJson.prices.length === 0) {
                    throw new Error('No se encontraron datos históricos para Supra');
                }

                // Construir datos OHLC simulados basados en precios históricos
                historicalData = historicalJson.prices.map((priceData, index) => {
                    const timestamp = new Date(priceData[0]);
                    const basePrice = priceData[1];
                    // Simular OHLC con pequeñas variaciones para análisis técnico
                    const open = basePrice;
                    const high = open * (1 + Math.random() * 0.005);
                    const low = open * (1 - Math.random() * 0.005);
                    const close = open + (Math.random() - 0.5) * (high - low);
                    const volume = 1000000 + Math.random() * 5000000; // Volumen simulado
                    return {
                        timestamp: timestamp,
                        open: open,
                        high: high,
                        low: low,
                        close: close,
                        volume: volume
                    };
                });

                document.getElementById('price').innerText = `Precio actual: $${currentPrice.toFixed(6)} USD`;
                document.getElementById('error').innerText = '';

                // Calcular indicadores
                const atr = calculateATR(historicalData, atrPeriod);
                const lastATR = atr[atr.length - 1];
                document.getElementById('atr').innerText = `ATR (14): ${lastATR.toFixed(6)} (Medida de volatilidad)`;

                const rsi = calculateRSI(historicalData.map(d => d.close), rsiPeriod);
                const lastRSI = rsi[rsi.length - 1];
                document.getElementById('rsi').innerText = `RSI (14): ${lastRSI.toFixed(2)} (Sobrevendido si <30, Sobrecomprado si >70)`;

                // Tendencia de volumen
                const recentVolumeAvg = historicalData.slice(-5).reduce((sum, d) => sum + d.volume, 0) / 5;
                const prevVolumeAvg = historicalData.slice(-10, -5).reduce((sum, d) => sum + d.volume, 0) / 5;
                const volumeTrend = recentVolumeAvg > prevVolumeAvg ? 'Aumentando (Bullish)' : 'Disminuyendo (Bearish)';
                document.getElementById('volume-trend').innerText = `Tendencia de Volumen: ${volumeTrend}`;

                // Niveles Fibonacci basados en high/low de los últimos 24 datos (~24 horas)
                const recentData = historicalData.slice(-24);
                const recentHigh = Math.max(...recentData.map(d => d.high));
                const recentLow = Math.min(...recentData.map(d => d.low));
                const fib = calculateFibLevels(recentHigh, recentLow);

                // Lógica de señal usando precio actual
                let signal = 'MANTENER';
                let advice = '';
                if (lastRSI < 30 && currentPrice > fib[0.618]) {
                    signal = 'COMPRAR';
                    advice = `Tendencia alcista. Compra alrededor de $${(currentPrice - lastATR).toFixed(6)} (soporte ATR). Objetivo: $${(currentPrice + 2 * lastATR).toFixed(6)}. Nivel Fib soporte: $${fib[0.618].toFixed(6)}.`;
                } else if (lastRSI > 70 && currentPrice < fib[0.382]) {
                    signal = 'VENDER';
                    advice = `Tendencia bajista. Vende alrededor de $${(currentPrice + lastATR).toFixed(6)} (resistencia ATR). Stop: $${(currentPrice - 2 * lastATR).toFixed(6)}. Nivel Fib resistencia: $${fib[0.382].toFixed(6)}.`;
                } else {
                    advice = 'Mantén posición. Monitorea para cambios en RSI o ruptura de niveles Fib.';
                }

                const signalElem = document.getElementById('signal');
                signalElem.innerText = signal;
                signalElem.className = signal === 'COMPRAR' ? 'buy' : signal === 'VENDER' ? 'sell' : '';

                document.getElementById('advice').innerText = advice;

                // Notificación
                if (signal !== currentSignal && signal !== 'MANTENER') {
                    alert(`¡Señal de ${signal}! ${advice}`);
                    // Para sonido: new Audio('alert.mp3').play(); (requiere archivo local)
                }
                currentSignal = signal;

                // Actualizar gráfico con datos históricos
                updateChart(historicalData, fib, currentPrice);

            } catch (error) {
                console.error(error);
                document.getElementById('signal').innerText = 'Error al cargar datos';
                document.getElementById('error').innerText = `Detalles del error: ${error.message}. Intenta de nuevo más tarde.`;
            }
        }

        function calculateATR(data, period) {
            if (data.length < period + 1) return [0]; // Datos insuficientes
            const tr = [];
            for (let i = 1; i < data.length; i++) {
                const highLow = data[i].high - data[i].low;
                const highClose = Math.abs(data[i].high - data[i - 1].close);
                const lowClose = Math.abs(data[i].low - data[i - 1].close);
                tr.push(Math.max(highLow, highClose, lowClose));
            }
            let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
            const atrArray = new Array(data.length - tr.length).fill(0).concat([atr]);
            for (let i = period; i < tr.length; i++) {
                atr = (atr * (period - 1) + tr[i]) / period;
                atrArray.push(atr);
            }
            return atrArray;
        }

        function calculateRSI(closes, period) {
            if (closes.length < period + 1) return [50]; // Neutral si datos insuficientes
            const gains = [], losses = [];
            for (let i = 1; i < closes.length; i++) {
                const diff = closes[i] - closes[i - 1];
                if (diff > 0) gains.push(diff); else losses.push(Math.abs(diff));
            }
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let rs = avgLoss ? avgGain / avgLoss : Infinity;
            let rsiValue = 100 - 100 / (1 + rs);
            const rsiArray = new Array(closes.length - gains.length - 1).fill(50).concat([rsiValue]);
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + (gains[i] || 0)) / period;
                avgLoss = (avgLoss * (period - 1) + (losses[i] || 0)) / period;
                rs = avgLoss ? avgGain / avgLoss : Infinity;
                rsiValue = 100 - 100 / (1 + rs);
                rsiArray.push(rsiValue);
            }
            return rsiArray;
        }

        function calculateFibLevels(high, low) {
            const diff = high - low;
            return fibLevels.reduce((acc, level) => {
                acc[level] = high - level * diff;
                return acc;
            }, {});
        }

        function updateChart(data, fib, currentPrice) {
            const labels = data.map(d => d.timestamp.toLocaleString('es-ES', { hour: '2-digit', minute: '2-digit', day: 'numeric', month: 'short' }));
            const prices = data.map(d => d.close);

            if (!chart) {
                const ctx = document.getElementById('priceChart').getContext('2d');
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Precio SUPRA (USD)',
                            data: prices,
                            borderColor: '#6a00ff',
                            backgroundColor: 'rgba(106, 0, 255, 0.1)',
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { beginAtZero: false }
                        },
                        plugins: {
                            annotation: {
                                annotations: Object.entries(fib).map(([level, value]) => ({
                                    type: 'line',
                                    yMin: value,
                                    yMax: value,
                                    borderColor: '#00ff00',
                                    borderWidth: 1,
                                    label: {
                                        content: `${(level * 100).toFixed(1)}% Fib`,
                                        enabled: true,
                                        position: 'start'
                                    }
                                }))
                            }
                        }
                    }
                });
            } else {
                chart.data.labels = labels;
                chart.data.datasets[0].data = prices;
                chart.options.plugins.annotation.annotations = Object.entries(fib).map(([level, value]) => ({
                    type: 'line',
                    yMin: value,
                    yMax: value,
                    borderColor: '#00ff00',
                    borderWidth: 1,
                    label: {
                        content: `${(level * 100).toFixed(1)}% Fib`,
                        enabled: true,
                        position: 'start'
                    }
                }));
                chart.update();
            }
        }

        // Inicializar
        fetchData();
        setInterval(fetchData, 60000); // Cada 60 segundos

        document.getElementById('refresh').addEventListener('click', fetchData);
    </script>
    <p>0.3</p>
</body>
</html>